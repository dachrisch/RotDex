package com.rotdex.data.manager

import com.rotdex.data.database.CardDao
import com.rotdex.data.database.FusionHistoryDao
import com.rotdex.data.models.*
import kotlin.random.Random

/**
 * Manager for card fusion operations
 */
class FusionManager(
    private val cardDao: CardDao,
    private val fusionHistoryDao: FusionHistoryDao
) {

    /**
     * Validate if fusion can be performed
     */
    fun validateFusion(cards: List<Card>): FusionValidation {
        return FusionRules.canFuse(cards)
    }

    /**
     * Perform card fusion
     * @param inputCards Cards to fuse (will be deleted)
     * @return FusionResult with the result card and details
     */
    suspend fun performFusion(inputCards: List<Card>): FusionResult {
        // Validate fusion
        val validation = validateFusion(inputCards)
        if (validation is FusionValidation.Error) {
            throw IllegalArgumentException(validation.message)
        }

        // Check for matching recipe
        val matchingRecipe = FusionRecipes.findMatchingRecipe(inputCards)

        // Calculate success rate
        val baseSuccessRate = (validation as FusionValidation.Valid).successRate
        val recipeBonus = if (matchingRecipe != null) 0.2f else 0f // +20% for recipe match
        val finalSuccessRate = minOf(1f, baseSuccessRate + recipeBonus)

        // Determine if fusion succeeded
        val randomValue = Random.nextFloat()
        val wasSuccessful = randomValue < finalSuccessRate

        // Generate result card
        val resultCard = generateResultCard(inputCards, matchingRecipe, wasSuccessful)

        // Save result card to database
        val resultCardId = cardDao.insertCard(resultCard)
        val savedResultCard = resultCard.copy(id = resultCardId)

        // Determine fusion type
        val fusionType = FusionRules.getFusionType(
            cardCount = inputCards.size,
            hasRecipe = matchingRecipe != null
        )

        // Record fusion in history
        val fusionHistory = FusionHistory(
            inputCardIds = inputCards.map { it.id },
            inputRarities = inputCards.map { it.rarity },
            resultCardId = resultCardId,
            resultRarity = savedResultCard.rarity,
            fusionType = fusionType,
            wasSuccessful = wasSuccessful,
            recipeUsed = matchingRecipe?.id
        )
        fusionHistoryDao.insertFusion(fusionHistory)

        // Delete input cards
        inputCards.forEach { card ->
            cardDao.deleteCard(card)
        }

        // Check if this is a new recipe discovery
        val recipeDiscovered = if (matchingRecipe != null && matchingRecipe.isSecret) {
            val previouslyDiscovered = fusionHistoryDao.isRecipeDiscovered(matchingRecipe.id) > 1 // >1 because we just inserted
            if (!previouslyDiscovered) matchingRecipe else null
        } else null

        return FusionResult(
            success = wasSuccessful,
            resultCard = savedResultCard,
            rarityUpgraded = savedResultCard.rarity != inputCards.first().rarity,
            bonusApplied = matchingRecipe?.name,
            recipeDiscovered = recipeDiscovered
        )
    }

    /**
     * Generate the result card from fusion
     */
    private fun generateResultCard(
        inputCards: List<Card>,
        recipe: FusionRecipe?,
        wasSuccessful: Boolean
    ): Card {
        val inputRarity = inputCards.first().rarity

        // Determine result rarity
        val resultRarity = when {
            recipe != null -> {
                // Recipe with guaranteed rarity, but can upgrade further on success
                if (wasSuccessful) {
                    FusionRules.getNextRarity(recipe.guaranteedRarity)
                } else {
                    recipe.guaranteedRarity
                }
            }
            wasSuccessful -> FusionRules.getNextRarity(inputRarity)
            else -> inputRarity
        }

        // Combine prompts to create fusion prompt
        val fusionPrompt = when {
            recipe != null -> {
                "Fusion of ${inputCards.size} cards (${recipe.name}): " +
                        inputCards.take(2).joinToString(" + ") { it.prompt.take(30) }
            }
            else -> {
                "Fusion of ${inputCards.size} ${inputRarity.displayName} cards"
            }
        }

        // Combine tags
        val allTags = inputCards.flatMap { it.tags }.distinct().toMutableList()
        allTags.add("fusion")
        if (recipe != null) {
            allTags.addAll(recipe.guaranteedTags)
        }

        return Card(
            prompt = fusionPrompt,
            imageUrl = "", // Will need to be generated by AI later
            rarity = resultRarity,
            tags = allTags.distinct(),
            createdAt = System.currentTimeMillis()
        )
    }

    /**
     * Get discovered recipes
     */
    suspend fun getDiscoveredRecipes(): List<FusionRecipe> {
        val discoveredIds = fusionHistoryDao.getDiscoveredRecipes()
        return discoveredIds.mapNotNull { FusionRecipes.getRecipeById(it) }
    }

    /**
     * Get fusion statistics
     */
    suspend fun getFusionStats(): FusionStats {
        val totalFusions = fusionHistoryDao.getTotalFusionCount()
        val successfulFusions = fusionHistoryDao.getSuccessfulFusionCount()
        val successRate = fusionHistoryDao.getSuccessRate() ?: 0f

        val fusionsByRarity = mapOf(
            CardRarity.COMMON to fusionHistoryDao.getFusionCountByRarity(CardRarity.COMMON),
            CardRarity.RARE to fusionHistoryDao.getFusionCountByRarity(CardRarity.RARE),
            CardRarity.EPIC to fusionHistoryDao.getFusionCountByRarity(CardRarity.EPIC),
            CardRarity.LEGENDARY to fusionHistoryDao.getFusionCountByRarity(CardRarity.LEGENDARY)
        )

        return FusionStats(
            totalFusions = totalFusions,
            successfulFusions = successfulFusions,
            successRate = successRate,
            fusionsByRarity = fusionsByRarity
        )
    }
}

/**
 * Fusion statistics
 */
data class FusionStats(
    val totalFusions: Int,
    val successfulFusions: Int,
    val successRate: Float,
    val fusionsByRarity: Map<CardRarity, Int>
)
